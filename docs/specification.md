# MineChat Protocol Specification

*Version 1.0.0*

## 1. Purpose

The MineChat Protocol defines a secure, binary-framed, compressed, client-server protocol that enables users to interact with a Minecraft server's chat system **without being logged into Minecraft on the same device**.

The protocol is designed to:

- Support multiple external client devices per Minecraft account
- Preserve Minecraft-compatible text formatting
- Allow moderation at both per-device and per-account granularity
- Operate without reliance on public Certificate Authorities
- Be efficient, extensible, and implementation-agnostic

This specification defines **wire-level behavior only**. User interfaces, database schemas, command names, and server-side storage formats are **explicitly out of scope**.

## 2. Terminology and Conventions

The key words **MUST**, **MUST NOT**, **SHOULD**, **SHOULD NOT**, and **MAY** are to be interpreted as described in RFC 2119.

- **Client**: An external MineChat client application.
- **Server**: A MineChat server component integrated with a Minecraft server.
- **Linking**: The process of associating a client device with a Minecraft account.
- **Client UUID**: A UUID generated by the client to identify a specific device.
- **Minecraft UUID**: The UUID of a Minecraft account.
- **RTT (Round-Trip Time)**: Time elapsed between sending a PING and receiving the corresponding PONG.

## 3. Transport and Security

### 3.1 TLS

All connections **MUST** be established over TLS.

- Servers **MUST** present a self-signed TLS certificate.
- Clients **MUST** perform certificate pinning after linking.
- Public Certificate Authorities are **NOT REQUIRED**.

### 3.2 Certificate Pinning

- During initial linking, the client stores the server's certificate or public key.
- On subsequent connections, the client **MUST reject** the connection if the presented certificate does not match the pinned certificate.
- Behavior on certificate rotation is **implementation-defined**, but certificate mismatch **MUST** cause connection failure.

## 4. Framing Layer

All MineChat messages are transmitted using a **length-prefixed binary framing format**.

### 4.1 Frame Structure

Each frame consists of:

```
[4 bytes decompressed size]
[4 bytes compressed size]
[compressed payload bytes]
```

### 4.2 Integer Encoding

- All framing integers **MUST** be:
  * 32-bit signed integers
  * Big-endian (network byte order)
- Negative or zero sizes **MUST** terminate the connection

### 4.3 Semantics

- `decompressed size` indicates the exact byte length after decompression.
- `compressed size` indicates the byte length of the compressed payload.
- Receivers **MUST** read exactly the specified number of bytes.
- Mismatched sizes or decompression failure **MUST** result in connection termination.

## 5. Compression

- All payloads **MUST** be compressed using **zstd**.
- Compression is **mandatory and unconditional**.
- There is **no negotiation** for compression.
- Compression is applied **after CBOR serialization**.

Pipeline:

```
CBOR encode → zstd compress → frame → TLS
```

## 6. CBOR Usage

### 6.1 General Rules

This specification defines semantic meaning for CBOR map keys within defined numeric ranges. These ranges are a MineChat protocol convention and are not imposed by CBOR itself. Implementations MUST interpret map keys according to this specification and MUST ignore unknown keys unless explicitly stated otherwise.

- All payloads **MUST** be encoded as CBOR maps.
- CBOR map keys are **semantic identifiers**, not ordered fields.
- Implementations **MUST NOT** rely on map ordering.
- Unknown keys **MUST be ignored** to allow extensibility.

### 6.2 Field Types

Unless otherwise stated:

- Integers inside CBOR are standard CBOR integers (variable width).
- Strings are UTF-8 text strings.
- UUIDs are encoded as text strings in canonical UUID format.

### 6.3 Simplified CBOR Notation

This specification uses a **simplified CBOR representation** for readability, for example:

```
{
  0: 1,
  1: "hello"
}
```

This notation is **illustrative only** and represents a CBOR map, not JSON.

## 7. Packet Model

### 7.1 Packet Direction

Each packet is either:

- **Clientbound** (Server → Client)
- **Serverbound** (Client → Server)

Each packet **MUST** include a packet type identifier.

### 7.2 Common Packet Envelope

All packets share the following top-level structure:

```
{
  0: packet_type (int),
  1: payload (map)
}
```

## 8. Packet Types

### 8.1 LINK (Serverbound)

Sent by the client during initial linking.

```
Packet Type: 0x01
Direction: Client → Server
```

Payload:

```
{
  0: linking_code (string),
  1: client_uuid (string)
}
```

### 8.2 LINK_OK (Clientbound)

Sent by the server when linking succeeds.

```
Packet Type: 0x02
Direction: Server → Client
```

Payload:

```
{
  0: minecraft_uuid (string)
}
```

### 8.3 CAPABILITIES (Serverbound)

Sent by the client immediately after linking or reconnecting.

```
Packet Type: 0x03
Direction: Client → Server
```

Payload:

```
{
  0: supports_components (bool)
}
```

### 8.4 AUTH_OK (Clientbound)

Indicates authentication completion.

```
Packet Type: 0x04
Direction: Server → Client
```

Payload:

```
{}
```

### 8.5 CHAT_MESSAGE (Bidirectional)

```
Packet Type: 0x05
Direction: Client ↔ Server
```

Payload:

```
{
  0: format (string),     ; "commonmark" or "components"
  1: content (string)
}
```

#### Format Semantics

- `commonmark`:
  * Content is CommonMark Markdown
  * Reference: <https://commonmark.org/>
- `components`:
  * Content is a JSON-encoded Minecraft Text Component
  * Based on the official text component format: <https://minecraft.wiki/w/Text_component_format>
  * Produced by Paper / Adventure: <https://papermc.io/>

### 8.6 PING (Bidirectional)

```
Packet Type: 0x06
```

Payload:

```
{
  0: timestamp_ms (int)
}
```

### 8.7 PONG (Bidirectional)

```
Packet Type: 0x07
```

Payload:

```
{
  0: timestamp_ms (int)
}
```

The timestamp **MUST** match the corresponding PING.

### 8.8 MODERATION (Clientbound)

```
Packet Type: 0x08
Direction: Server → Client
```

Payload:

```
{
  0: action (int),        ; warn=0, mute=1, kick=2, ban=3
  1: scope (int),         ; client=0, account=1
  2: reason (string),     ; optional
  3: duration_seconds (int) ; optional
}
```

Clients **MUST** enforce moderation actions locally.

## 9. Keep-Alive

- Default keep-alive interval: **15 seconds**
- Interval **MAY** be configurable.
- Either side may send PING at any time.
- Failure to receive any packet within the timeout window **MUST** result in connection termination.

## 10. Packet Flow

### 10.1 Linking and Authentication

```
Player                  Server                Client
  |                       |                     |
  | /minechat link        |                     |
  |---------------------->|                     |
  |  linking code shown   |                     |
  |                       |                     |
  |                       |<--- TLS connect ----|
  |                       |---- TLS cert ------>|
  |                       |                     |
  |                       |<--- LINK -----------|
  |                       |---- LINK_OK --------|
  |                       |                     |
  |                       |<--- CAPABILITIES ---|
  |                       |---- AUTH_OK --------|
```

### 10.2 Sending a Chat Message

```
Client                         Server
  |                               |
  |--- CHAT_MESSAGE -------------->|
  |                               |
  |<-- CHAT_MESSAGE (broadcast) ---|
```

## 11. Security Considerations

- TLS provides confidentiality and integrity.
- Certificate pinning prevents MITM attacks.
- Mandatory compression and framing prevent stream desynchronization.
- Client UUIDs prevent trivial ban evasion.

## 12. Extensibility

- Unknown packet types **MUST** be ignored.
- Unknown CBOR fields **MUST** be ignored.
- Packet type identifiers SHOULD be centrally documented.

Good call — these two things are exactly what make a spec *implementable* instead of just “well written”.

Below is an **append-only extension** to the spec you already have. Nothing here contradicts it; this just tightens it and removes any remaining ambiguity.

## Appendix A — Packet Reference Table

This section provides a **single-glance reference** for implementors.
All packet structures are defined normatively in Section 8; this table is **non-normative but authoritative**.

### Packet Type Table

| Packet Name  | Type ID | Direction       | Mandatory | Purpose                                 |
| ------------ | ------: | --------------- | --------- | --------------------------------------- |
| LINK         |    0x01 | Client → Server | Yes       | Link client device to Minecraft account |
| LINK_OK      |    0x02 | Server → Client | Yes       | Confirm successful linking              |
| CAPABILITIES |    0x03 | Client → Server | Yes       | Declare client-supported features       |
| AUTH_OK      |    0x04 | Server → Client | Yes       | Authentication complete                 |
| CHAT_MESSAGE |    0x05 | Client ↔ Server | Yes       | Chat message transport                  |
| PING         |    0x06 | Client ↔ Server | Yes       | Keep-alive and RTT measurement          |
| PONG         |    0x07 | Client ↔ Server | Yes       | Response to PING                        |
| MODERATION   |    0x08 | Server → Client | Optional  | Enforce moderation actions              |

### Packet Field Reference

#### LINK (0x01)

| Key | Name         | Type   | Required |
| --- | ------------ | ------ | -------- |
| 0   | linking_code | string | Yes      |
| 1   | client_uuid  | string | Yes      |

#### LINK_OK (0x02)

| Key | Name           | Type   | Required |
| --- | -------------- | ------ | -------- |
| 0   | minecraft_uuid | string | Yes      |

#### CAPABILITIES (0x03)

| Key | Name                | Type | Required |
| --- | ------------------- | ---- | -------- |
| 0   | supports_components | bool | Yes      |

#### AUTH_OK (0x04)

No payload fields.

#### CHAT_MESSAGE (0x05)

| Key | Name    | Type   | Required |
| --- | ------- | ------ | -------- |
| 0   | format  | string | Yes      |
| 1   | content | string | Yes      |

Valid `format` values:

| Value        | Meaning                               |
| ------------ | ------------------------------------- |
| `commonmark` | CommonMark Markdown                   |
| `components` | JSON-encoded Minecraft Text Component |

#### PING (0x06)

| Key | Name         | Type | Required |
| --- | ------------ | ---- | -------- |
| 0   | timestamp_ms | int  | Yes      |

#### PONG (0x07)

| Key | Name         | Type | Required |
| --- | ------------ | ---- | -------- |
| 0   | timestamp_ms | int  | Yes      |

#### MODERATION (0x08)

| Key | Name             | Type   | Required |
| --- | ---------------- | ------ | -------- |
| 0   | action           | int    | Yes      |
| 1   | scope            | int    | Yes      |
| 2   | reason           | string | No       |
| 3   | duration_seconds | int    | No       |

Action values:

| Value | Meaning |
| ----: | ------- |
|     0 | Warn    |
|     1 | Mute    |
|     2 | Kick    |
|     3 | Ban     |

Scope values:

| Value | Meaning        |
| ----: | -------------- |
|     0 | Client UUID    |
|     1 | Minecraft UUID |

## Appendix B — Numeric Range Reservations

This section is **normative**.

### Packet Type ID Ranges

| Range     | Reservation                       |
| --------: | --------------------------------- |
| 0x00      | Reserved (invalid)                |
| 0x01-0x1F | Core protocol packets (this spec) |
| 0x20-0x3F | Future protocol extensions        |
| 0x40-0x7F | Experimental / non-standard       |
| 0x80-0xFF | Implementation-private            |

Rules:

- Core protocol packets **MUST** use IDs in `0x01-0x1F`
- Implementations **MUST NOT** redefine core packet IDs
- Experimental packets **MUST NOT** be required for interoperability
- Private packets **MUST NOT** be sent unless both sides explicitly support them

### CBOR Map Key Ranges

CBOR map keys inside packet payloads follow this reservation:

| Key Range | Meaning                             |
| --------: | ----------------------------------- |
|      0-31 | Core fields (this spec)             |
|     32-63 | Reserved for future core extensions |
|    64-127 | Optional extensions                 |
|      128+ | Implementation-defined              |

Rules:

- Core fields **MUST** use keys `0-31`
- Unknown keys **MUST** be ignored
- Implementations **MUST NOT** assume key ordering
